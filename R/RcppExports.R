# Generated by using Rcpp::compileAttributes() -> do not edit by hand
# Generator token: 10BE3573-1514-4C36-9D1C-5A225CD40393

#' Least-Squares Pooled Adjacent Violators Algorithm
#'
#' An implementation of the pooled adjacent violators algorithm for
#' minimizing the least squares loss subject to the monotonicity
#' (non-decreasing) constraint.
#'
#' It is assumed that `y` is ordered corresponding to the correct indices for
#' a monotone non-decreasing fit. If a monotone non-increasing fit is desired
#' use `base::rev()` as in the examples.
#'
#' The basic idea is to start by partitioning the data into singletons (zero
#' least squares loss), then merge neighboring sets if the monotone
#' non-decreasing constraint is violated. The value a set takes is the average
#' of its elements, this is implemented by tracking set cardinality and
#' the current mean so that the merger of two sets is just a weighted sum.
#'
#' This algorithm has time complexity O(n). However, this implementation may
#' have worse complexity because of the way we are removing elements in a
#' vector during the merge.
#'
#' @param y numeric vector of observations corresponding to a sorted,
#' increasing predictor
#' @return a  numeric vector of fitted values corresponding to y
#' @examples
#' # non-decreasing example
#' set.seed(1)
#' y <- atan(seq(from = -5, to = 5, length.out = 51)) + rnorm(51, sd = 0.2)
#' y.hat <- pava_ls(y) # not exported
#' plot(y)
#' points(y.hat, col = "red")
#'
#' #non-increasing example
#' set.seed(1)
#' y <- -atan(seq(from = -5, to = 5, length.out = 51)) + rnorm(51, sd = 0.2)
#' y.hat <- rev(pava_ls(rev(y)))
#' plot(y)
#' points(y.hat, col = "red")
#'
#' @useDynLib cole
#' @export
pava_ls <- function(y) {
    .Call('_coleReg_pava_ls', PACKAGE = 'coleReg', y)
}

